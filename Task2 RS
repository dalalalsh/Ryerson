#Dalal Alsharif - Capstone project - Recommender systems code

# install following three packages in R
library(recommenderlab)
library(reshape2)
library(ggplot2)
require(devtools) 

# Get additional recommendation algorithms
install_github("sanealytics", "recommenderlabrats")

# Remove ALL column EXEPT custAttr1, custAttr2, target. We do not need it 
tr = train[,c("amount", "custAttr1","field1", "flag2", "flag3", "flag5", "target")]

#trmelt = melt(tr, id = "custAttr1", measure = c("amount", "field1", "flag2", "flag3", "flag5"), value = "target")

# Using acast to convert above data
g = acast(tr, custAttr1 ~ field1 + flag2 + flag3 + flag5)

# Check the class of g
class(g)

# Convert it as a matrix
R = as.matrix(g)

# Convert R into realRatingMatrix data structure
#   realRatingMatrix is a recommenderlab sparse-matrix like data-structure
r <- as(R, "realRatingMatrix")
r

### Method 1:
scheme = evaluationScheme(testData, method = "split", train = .8,
                           k = 1, given = 10, goodRating = 1) 
scheme

# creation of recommender model based on ubcf
Rec.ubcf <- Recommender(getData(scheme, "train"), "UBCF")
# creation of recommender model based on ibcf for comparison
Rec.ibcf <- Recommender(getData(scheme, "train"), "IBCF")

# making predictions on the test data set
p.ubcf <- predict(Rec.ubcf, getData(scheme, "known"), type="ratings")
# making predictions on the test data set
p.ibcf <- predict(Rec.ibcf, getData(scheme, "known"), type="ratings")

p.ibcf@data@x = ifelse(p.ibcf@data@x > 0.5,1,0)
p.ubcf@data@x = ifelse(p.ubcf@data@x > 0.5,1,0)

# obtaining the error metrics for both approaches and comparing them
# RMSE, MSE, and MAE
error.ubcf<-calcPredictionAccuracy(p.ubcf, getData(scheme, "unknown"))
error.ibcf<-calcPredictionAccuracy(p.ibcf, getData(scheme, "unknown"))
error <- rbind(error.ubcf,error.ibcf)
rownames(error) <- c("UBCF","IBCF")

# Accuracy
accuracy = c((1 - error[1,3])*100, (1 - error[2,3])*100)
error = cbind(error, accuracy)
error



### Method 2 ########################## NO RESULTS YET
# I can turn it into data-frame
head(as(r, "data.frame"))

# normalize the rating matrix
r_m = normalize(r)
r_m
as(r_m, "list")

# Draw an image plot of raw-ratings & normalized ratings
#  A column represents one specific state and ratings by users
#   are shaded.
#   Note that some items are always rated 'black' by most users
#    while some items are not rated by many users
#     On the other hand a few users always give high ratings
#      as in some cases a series of black dots cut across items
image(r, main = "Raw Ratings")       
image(r_m, main = "Normalized Ratings")

# Can also turn the matrix into a 0-1 binary matrix
r_b = binarize(r, minRating=1)
as(r_b, "matrix")

############ Training and Testing #############################
# Randomly shuffle the data
set.seed(1)
train = train[sample(nrow(train)),]

# Create 10 equally size folds
folds = cut(seq(1,nrow(train)),breaks=10,labels=FALSE)

i = 1     #later apply 10-folds

# Segement your data by fold using the which() function 
testIndexes = which(folds==i,arr.ind=TRUE)
testData = train[testIndexes, ]
trainData = train[-testIndexes, ]

############ Create a recommender object (model) #############################
#   Run anyone of the following four code lines.
#     Do not run all four
#       They pertain to four different algorithms.
#        UBCF: User-based collaborative filtering
#        IBCF: Item-based collaborative filtering
#      Parameter 'method' decides similarity measure
#        Cosine or Jaccard
rec=Recommender(trainData,method="UBCF", param=list(normalize = "Z-score",method="Cosine",minRating=0))
rec=Recommender(trainData,method="UBCF", param=list(normalize = "Z-score",method="Jaccard",nn=5, minRating=0))
rec=Recommender(trainData,method="IBCF", param=list(normalize = "Z-score",method="Jaccard",minRating=0))
rec=Recommender(trainData,method="POPULAR")
rec=Recommender(trainData,method="SVD")
rec=Recommender(trainData,method="RSVD")

# Depending upon your selection, examine what you got
print(rec)
getModel(rec)

############ Create predictions #############################
# This prediction does not predict transation types for test.
#   But it fills up the user 'X' item matrix so that
#    for any userid and transactionid, I can find predicted rating
#     dim(r) shows there are 7373 users (rows)
#      'type' parameter decides whether you want ratings or top-n items
#         get top-10 recommendations for a user, as:
#             predict(rec, r[1:nrow(r)], type="topNList", n=10)
recom <- predict(rec, testData, type="ratings")
recom
